<h2>Avoiding NPEs. Null safety</h2>
<div class="step-text">
<p>Null safety is a crucial feature in Kotlin's design, addressing the notorious 'Billion Dollar Mistake'â€”the use of null references in programming. Kotlin's type system aims to get rid of null references, which commonly lead to bugs and crashes in software development.</p><p>In Kotlin, types are non-nullable by default. If you attempt to assign or return null to a non-nullable variable, the compiler will give an error:</p><pre><code class="language-kotlin">var name: String = "Kotlin"
name = null // Compiler error
</code></pre><p>To permit a variable to carry a null value, you must declare it as nullable by adding a <code class="language-kotlin">?</code> to its type:</p><pre><code class="language-kotlin">var name: String? = "Kotlin"
name = null // This is fine
</code></pre><p>Kotlin offers several mechanisms to deal with nullable types securely:</p><ol><li><p><strong>Safe Calls (</strong><code class="language-kotlin">?.</code>): This allows you to perform operations on a nullable object only if it's not null.</p></li></ol><pre><code class="language-kotlin">val length = name?.length // length is null if name is null
</code></pre><ol><li><p><strong>Elvis Operator (</strong><code class="language-kotlin">?:</code>): It furnishes a default value if the expression to the left is null.</p></li></ol><pre><code class="language-kotlin">val length = name?.length ?: 0 // length is 0 if name is null
</code></pre><ol><li><p><strong>Non-Null Assertion (</strong><code class="language-kotlin">!!</code>): Transforms a nullable type to a non-nullable type, throwing an exception if the value is null.</p></li></ol><pre><code class="language-kotlin">val length = name!!.length // Throws NullPointerException if name is null
</code></pre><ol><li><p><strong>Safe Casting (</strong><code class="language-kotlin">as?</code>): Safely casts to a type and returns null if the casting isn't possible.</p></li></ol><pre><code class="language-kotlin">val x: Any = "Kotlin"
val y: String? = x as? String // y is safely cast to String or null
</code></pre><p>Kotlin, by offering these tools, assists developers in averting null reference errors, making the code more stable and easy to maintain.</p><h5 id="understanding-nullable-types-in-kotlin">Understanding Nullable Types in Kotlin</h5><p>Kotlin seeks to eliminate the dreaded <code class="language-kotlin">NullPointerException</code> from our code by introducing a clear distinction between nullable and non-nullable types.</p><p><strong>Non-Nullable Types:</strong> By default, variables in Kotlin are non-nullable. If you try to assign or return <code class="language-kotlin">null</code> in a non-nullable variable, the compiler will give an error.</p><pre><code class="language-kotlin">var name: String = "Kotlin"
name = null // Compiler error
</code></pre><p><strong>Nullable Types:</strong> To declare a variable that can hold a <code class="language-kotlin">null</code> value, you append a question mark <code class="language-kotlin">?</code> to the type.</p><pre><code class="language-kotlin">var name: String? = "Kotlin"
name = null // This is fine
</code></pre><p>When you work with nullable types, Kotlin requires you to handle the possibility of <code class="language-kotlin">null</code> values explicitly, thereby making your code safer and more predictable.</p><p><strong>Safe Calls (</strong><code class="language-kotlin">?.</code>): Kotlin provides the safe call operator that allows you to access properties or call methods on nullable variables without risking a <code class="language-kotlin">NullPointerException</code>.</p><pre><code class="language-kotlin">val length = name?.length // length is null if name is null
</code></pre><p><strong>Elvis Operator (</strong><code class="language-kotlin">?:</code>): The Elvis operator allows you to provide a default value if the expression to the left is <code class="language-kotlin">null</code>.</p><pre><code class="language-kotlin">val length = name?.length ?: 0 // length is 0 if name is null
</code></pre><p><strong>Non-null Assertion (</strong><code class="language-kotlin">!!</code>): If you're absolutely certain a nullable reference isn't null, you can use the non-null assertion operator to throw an exception if the value turns out to be <code class="language-kotlin">null</code>.</p><pre><code class="language-kotlin">val length = name!!.length // Throws NullPointerException if name is null
</code></pre><p>Separated between nullable and non-nullable types, Kotlin provides a sturdy mechanism for managing <code class="language-kotlin">null</code>, making your code less vulnerable to <code class="language-kotlin">NullPointerException</code>s.</p><h5 id="safe-calls-and-the-elvis-operator-in-kotlin">Safe Calls and the Elvis Operator in Kotlin</h5><p>Kotlin targets to remove the feared <code class="language-kotlin">NullPointerException</code> from our code by bringing in null safety features. Two such features are safe calls and the Elvis operator.</p><h5 id="safe-calls">Safe Calls (?.)</h5><p>Safe calls allow you to access properties and methods of nullable objects without risk of a <code class="language-kotlin">NullPointerException</code>. When you use a safe call, Kotlin checks for null before performing the operation. If the object is null, it will return null instead of casting an exception.</p><p>Here's how to use a safe call:</p><pre><code class="language-kotlin">val name: String? = person?.name</code></pre><p>If <code class="language-kotlin">person</code> is not null, <code class="language-kotlin">name</code> will be assigned the value of <code class="language-kotlin">person.name</code>. If <code class="language-kotlin">person</code> is null, <code class="language-kotlin">name</code> will be null.</p><h5 id="the-elvis-operator">The Elvis Operator (?:)</h5><p>The Elvis operator lets you provide an alternative value in case the expression to its left is null. This is particularly handy for delivering default values or resorting to a safe operation.</p><p>Here's an example of using the Elvis operator:</p><pre><code class="language-kotlin">val name: String = person?.name ?: "Unknown"</code></pre><p>In this case, if <code class="language-kotlin">person</code> isn't null and <code class="language-kotlin">person.name</code> isn't null, <code class="language-kotlin">name</code> will be given the value of <code class="language-kotlin">person.name</code>. If either <code class="language-kotlin">person</code> or <code class="language-kotlin">person.name</code> is null, <code class="language-kotlin">name</code> will receive the value "Unknown".</p><p>Using safe calls in combination with the Elvis operator provides a powerful tool for dealing with nullable types in Kotlin, reducing the risk of <code class="language-kotlin">NullPointerException</code> and making your code more concise and secure.</p><h5 id="the-operator-in-kotlin-use-with-caution">The <code class="language-kotlin">!!</code> Operator in Kotlin: Use With Caution</h5><p>Kotlin, designed to eradicate the <code class="language-kotlin">NullPointerException</code> from your code, introduces features that ensure null safety. However, the <code class="language-kotlin">!!</code> operator is an exception that reintroduces the potential for such errors. It forcefully casts a nullable type to a non-null type.</p><pre><code class="language-kotlin">val name: String? = null
val nonNullName: String = name!! // Throws NullPointerException
</code></pre><p>The <code class="language-kotlin">!!</code> operator asserts that the value is non-null, and if it's actually null, a <code class="language-kotlin">NullPointerException</code> is cast immediately. This is contrary to Kotlin's philosophy of null safety and should be used sparingly.</p><h5 id="why-overuse-is-problematic">Why Overuse is Problematic:</h5><ol><li><p><strong>Defeats Null Safety</strong>: Kotlin's type system is designed to handle nulls gracefully. Overusing <code class="language-kotlin">!!</code> bypasses these safety measures.</p></li><li><p><strong>Code Smell</strong>: Regular use often indicates a disregard for proper null checks and can lead to code that's less stable and more challenging to maintain.</p></li><li><p><strong>Unexpected Crashes</strong>: It can cause your application to crash unexpectedly if proper null checks are not done before using <code class="language-kotlin">!!</code>.</p></li></ol><h5 id="safer-alternatives">Safer Alternatives:</h5><ul><li><p><strong>Safe Calls (</strong><code class="language-kotlin">?.</code>): Returns the value if it's non-null; otherwise, returns null.</p><pre><code class="language-kotlin">val length = name?.length // Safe call, length will be null if name is null
            </code></pre></li><li><p><strong>Elvis Operator (</strong><code class="language-kotlin">?:</code>): Delivers a default value if the expression to the left is null.</p><pre><code class="language-kotlin">val length = name?.length ?: 0 // If name is null, length will be 0
            </code></pre></li><li><p><strong>Safe Casting (</strong><code class="language-kotlin">as?</code>): Safely casts to the given type or returns null if the cast isn't possible.</p><pre><code class="language-kotlin">val nullableInt: Int? = something as? Int
            </code></pre></li><li><p><strong>Let Function</strong>: Executes a block of code if the variable is not null.</p><pre><code class="language-kotlin">name?.let { 
    println("Name is $it") 
}
            </code></pre></li></ul><p>In conclusion, the <code class="language-kotlin">!!</code> operator should be your last option. Embrace Kotlin's null safety features to write robust, crash-resistant code.</p><h5 id="best-practices-for-null-safety-in-kotlin">Best Practices for Null Safety in Kotlin</h5><p>Kotlin's type system is designed to eliminate the danger of null references from the code, also known as the billion-dollar mistake. Here are some best practices to enforce null safety:</p><ol><li><p><strong>Use Nullable Types Wisely</strong>: Only use nullable types (<code class="language-kotlin">Type?</code>) when a variable can indeed be <code class="language-kotlin">null</code>. If a variable should not be <code class="language-kotlin">null</code>, use a non-nullable type.</p></li><li><p><strong>Safe Calls (</strong><code class="language-kotlin">?.</code>): Use the safe call operator when accessing properties or methods on a nullable object. This will return <code class="language-kotlin">null</code> if the object is <code class="language-kotlin">null</code> instead of throwing a <code class="language-kotlin">NullPointerException</code>.</p><pre><code class="language-kotlin">val length = nullableString?.length</code></pre></li><li><p><strong>Elvis Operator (</strong><code class="language-kotlin">?:</code>): The Elvis operator lets you to offer an alternative value if an expression evaluates to <code class="language-kotlin">null</code>.</p><pre><code class="language-kotlin">val length = nullableString?.length ?: 0</code></pre></li><li><p><strong>Non-Null Assertion (</strong><code class="language-kotlin">!!</code>): Use this operator only when you are certain that the value is not <code class="language-kotlin">null</code>. It will throw a <code class="language-kotlin">NullPointerException</code> if the value is <code class="language-kotlin">null</code>.</p><pre><code class="language-kotlin">val length = nullableString!!.length</code></pre></li><li><p><strong>Use </strong><code class="language-kotlin">let</code> for Null Checks: The <code class="language-kotlin">let</code> function can be used to execute block of code only if the variable is not <code class="language-kotlin">null</code>.</p><pre><code class="language-kotlin">nullableString?.let {
    // Code here will only run if nullableString is not null
}</code></pre></li><li><p><strong>Use </strong><code class="language-kotlin">apply</code> for Configuration: Use <code class="language-kotlin">apply</code> on a nullable object to configure it if it's not <code class="language-kotlin">null</code>.</p><pre><code class="language-kotlin">nullableObject?.apply {
    // Configure object here
}</code></pre></li><li><p><strong>Use </strong><code class="language-kotlin">takeIf</code> and <code class="language-kotlin">takeUnless</code>: These functions are useful for conditional checks that return <code class="language-kotlin">null</code> if the condition is not met.</p><pre><code class="language-kotlin">val positiveNumber = input.takeIf { it &gt; 0 }
val notBlankString = input.takeUnless { it.isBlank() }</code></pre></li><li><p><strong>Design APIs for Null Safety</strong>: When designing APIs, use default parameters and provide non-null types. This encourages API consumers to think about nullability and reduces chances of <code class="language-kotlin">NullPointerException</code>.</p><pre><code class="language-kotlin">fun process(input: String = "") { /*...*/ }</code></pre></li></ol><p>By following these practices and utilising Kotlin's standard library functions, you can write more robust and null-safe code. Remember, the key to avoiding <code class="language-kotlin">NullPointerException</code> is to write code that communicates nullability explicitly and handles it gracefully.</p><h5 id="conclusion">Conclusion</h5><p>Kotlin's null safety features aim to reduce the risks associated with null references, often referred to as the "Billion Dollar Mistake". By making types non-nullable by default and providing explicit nullable types, Kotlin compels developers to handle the possibility of null values in a controlled way. Safe calls, the Elvis operator, safe casting, and the <code class="language-kotlin">let</code> function are among the tools provided by Kotlin to handle nullable types securely and prevent <code class="language-kotlin">NullPointerException</code>.</p>
</div>
